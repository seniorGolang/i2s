package server

import (
	"context"
	"path"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/vetcher/go-astra/types"

	"github.com/seniorGolang/i2s/pkg/tags"
	"github.com/seniorGolang/i2s/pkg/utils"
)

func renderTransportHttpServer(info *GenerationInfo) (err error) {

	srcFile := NewFileProxy(info.PkgName)

	srcFile.PackageComment("GENERATED BY i2s. DO NOT EDIT.")

	srcFile.ImportName(packageIO, "io")
	srcFile.ImportName(packageUUID, "uuid")
	srcFile.ImportName(packageGorillaMux, "mux")

	ctx := prepareContext(info)
	ctx = context.WithValue(ctx, "code", srcFile)

	for _, fn := range info.Iface.Methods {

		if name := tags.ParseTags(fn.Docs).Value("http-decoder", "-"); name == "-" {
			srcFile.Line().Add(decodeHTTPRequest(ctx, fn, info)).Line()
		}
	}

	srcFile.Line().Add(commonHTTPResponseEncoder())

	return srcFile.Save(path.Join(info.OutputFilePath, "transport", strings.ToLower(info.ServiceName), "http.go"))
}

func decodeHTTPRequest(ctx context.Context, fn *types.Function, info *GenerationInfo) *Statement {

	return Func().Id(utils.ToCamel(decodeRequestName(fn)+"Http")).
		Params(
			Id("_").Qual(packagePathContext, "Context"),
			Id("r").Op("*").Qual(packagePathHttp, "Request"),
		).Params(
		Interface(),
		Error(),
	).BlockFunc(func(g *Group) {

		var urlVars []string

		if args := urlArgs(fn, g); len(args) > 0 {
			urlVars = append(urlVars, args...)
		}

		if args := urlParams(fn, g); len(args) > 0 {
			urlVars = append(urlVars, args...)
		}

		if args := httpHeaders(fn, g); len(args) > 0 {
			urlVars = append(urlVars, args...)
		}

		arguments := removeContextIfFirst(fn.Args)

		if len(arguments) == 0 {
			g.Return(Nil(), Nil())
			return
		}

		if len(arguments) == 1 && len(urlVars) == 0 {

			g.Line().Var().Id("req").Add(fieldType(ctx, arguments[0].Type, false))
			g.Err().Op(":=").Qual(packagePathJson, "NewDecoder").Call(Id("r").Dot("Body")).Dot("Decode").Call(Op("&").Id("req"))
			g.Return(Id("req"), Err())
			return
		}

		if len(arguments) == 1 && len(urlVars) > 0 {
			g.Return(Id(urlVars[0]), Nil())
			return

		} else {

			if len(urlVars) == 0 {
				g.Var().Id("req").Id(requestStructName(fn))
				g.Err().Op(":=").Qual(packagePathJson, "NewDecoder").Call(Id("r").Dot("Body")).Dot("Decode").Call(Op("&").Id("req"))
				g.Return(Id("req"), Err())
				return
			}

			diff := fields(fn, urlVars)

			g.Line().Var().Id("req").Id(requestStructName(fn))

			if len(diff) > 0 {
				g.If().Err().Op(":=").Qual(packagePathJson, "NewDecoder").Call(Id("r").Dot("Body")).Dot("Decode").Call(Op("&").Id("req")).
					Op(";").Err().Op("!=").Nil().Op("&&").Err().Op("!=").Qual(packageIO, "EOF").Block(
					Return(Nil(), Err()),
				).Line()

			}

			for _, arg := range arguments {
				if _, found := diff[arg.Name]; !found {

					switch arg.Type.String() {
					case "int":
						g.Id("req").Op(".").Add(structFieldName(&arg)).Op("=").Id("int").Call(Id(arg.Name))
					default:
						g.Id("req").Op(".").Add(structFieldName(&arg)).Op("=").Id(arg.Name)
					}
				}
			}
			g.Line().Return(Id("req"), Nil())
		}
	})
}

func httpHeaders(fn *types.Function, g *Group) (urlVars []string) {

	if httpHeaders := tags.ParseTags(fn.Docs).Value("http-headers", ""); httpHeaders != "" {

		headerPairs := strings.Split(httpHeaders, ",")

		headers := make(map[string]string)

		for _, pair := range headerPairs {
			if pairTokens := strings.Split(pair, "|"); len(pairTokens) == 2 {
				arg := strings.TrimSpace(pairTokens[0])
				header := strings.ToLower(strings.TrimSpace(pairTokens[1]))
				urlVars = append(urlVars, arg)
				headers[arg] = header
			}
		}

		for arg, header := range headers {
			g.Line().Id("_" + arg).Op(":=").Id("r").Dot("Header").Dot("Get").Call(Lit(header))
			g.Add(argToTypeConverter(fn, "_"+arg))
		}
	}
	return
}

func urlArgs(fn *types.Function, g *Group) (urlVars []string) {

	if urlPath := tags.ParseTags(fn.Docs).Value("http-path", ""); urlPath != "" {

		urlTokens := strings.Split(urlPath, "/")

		for _, token := range urlTokens {
			if strings.HasPrefix(token, "{") {
				urlVars = append(urlVars, strings.TrimSpace(strings.Replace(strings.TrimPrefix(token, "{"), "}", "", -1)))
			}
		}

		if len(urlVars) > 0 {
			g.Line().Var().Id("ok").Bool()
			g.Id("vars").Op(":=").Qual(packageGorillaMux, "Vars").Call(Id("r"))
		}

		for _, param := range urlVars {

			g.Line().Var().Id("_" + param).String()
			g.If().List(Id("_"+param), Id("ok")).Op("=").Id("vars").Index(Lit(param)).
				Op(";").Op("!").Id("ok").Block(
				Return(Nil(), Qual(packagePathErrors, "New").Call(Lit("param "+param+" not found"))),
			)
			g.Line().Add(argToTypeConverter(fn, "_"+param))
		}
	}
	return
}

func urlParams(fn *types.Function, g *Group) (urlVars []string) {

	if urlArgs := tags.ParseTags(fn.Docs).Value("http-arg", ""); urlArgs != "" {

		urlArgs := strings.Split(urlArgs, ",")

		for _, token := range urlArgs {
			urlVars = append(urlVars, strings.TrimSpace(token))
		}

		for _, param := range urlVars {

			var isArray bool
			for _, arg := range fn.Args {

				if arg.Name == param {
					isArray = types.IsArray(arg.Type) || types.IsEllipsis(arg.Type)
					break
				}
			}

			if isArray {
				g.Line().Id("_" + param).Op(":=").Id("r").Dot("URL").Dot("Query").Call().Op("[").Lit(param).Op("]")
			} else {
				g.Line().Id("_" + param).Op(":=").Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(Lit(param))
			}
			g.Add(argToTypeConverter(fn, "_"+param))
		}
	}
	return
}

func commonHTTPResponseEncoder() *Statement {

	return Func().Id(commonHTTPResponseEncoderName).
		Params(
			Id("_").Qual(packagePathContext, "Context"),
			Id("w").Qual(packagePathHttp, "ResponseWriter"),
			Id("response").Interface(),
		).Params(
		Error(),
	).BlockFunc(func(g *Group) {
		g.Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json; charset=utf-8"))
		g.Return(
			Qual(packagePathJson, "NewEncoder").Call(Id("w")).Dot("Encode").Call(Id("response")),
		)
	})
}

func fields(fn *types.Function, args []string) (diff map[string]struct{}) {

	diff = make(map[string]struct{})

	arguments := removeContextIfFirst(fn.Args)

	for _, arg := range arguments {
		diff[arg.Name] = struct{}{}
	}

	for _, arg := range args {
		if _, found := diff[arg]; found {
			delete(diff, arg)
		}
	}
	return
}

func argToTypeConverter(fn *types.Function, argName string) *Statement {

	var arg types.Variable

	for _, arg = range fn.Args {
		if arg.Name == strings.TrimPrefix(argName, "_") {
			break
		}
	}

	return stringToTypeConverter(arg, arg.Name, Id(argName), true)
}

func stringToTypeConverter(v types.Variable, toId string, from Code, new bool) *Statement {

	op := "="

	if new {
		op = ":="
	}

	typename := types.TypeName(v.Type)
	if typename == nil {
		panic("need to check and update validation rules (2)")
	}
	switch *typename {
	case "string":
		return Id(toId).Op(":=").Add(from)
	case "int", "int64":
		return List(Id(toId), Err()).Op(op).Qual(packagePathStrconv, "ParseInt").Call(from, Lit(10), Lit(64)).
			Line().If(Err().Op("!=").Nil()).Block(
			Return(Nil(), Err()),
		)
	case "int32":
		return List(Id(toId), Err()).Op(op).Qual(packagePathStrconv, "ParseInt").Call(from, Lit(10), Lit(32)).
			Line().If(Err().Op("!=").Nil()).Block(
			Return(Nil(), Err()),
		)
	case "uint", "uint64":
		return List(Id(toId), Err()).Op(op).Qual(packagePathStrconv, "ParseUint").Call(from, Lit(10), Lit(64)).
			Line().If(Err().Op("!=").Nil()).Block(
			Return(Nil(), Err()),
		)
	case "uint32":
		return List(Id(toId), Err()).Op(op).Qual(packagePathStrconv, "ParseUint").Call(from, Lit(10), Lit(32)).
			Line().If(Err().Op("!=").Nil()).Block(
			Return(Nil(), Err()),
		)

	case "UUID":
		return Id(toId).Op(op).Qual(packageUUID, "FromStringOrNil").Call(from)

	case "Time":
		return List(Id(toId), Err()).Op(op).Qual(packagePathTime, "Parse").Call(Qual(packagePathTime, "RFC3339Nano"), from).
			Line().If(Err().Op("!=").Nil()).Block(
			Return(Nil(), Err()),
		)
	}
	return Line().Add(from)
}
