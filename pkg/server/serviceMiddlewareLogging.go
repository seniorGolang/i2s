package server

import (
	"context"
	"fmt"
	"path"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/vetcher/go-astra/types"

	"github.com/seniorGolang/i2s/pkg/meta"
	"github.com/seniorGolang/i2s/pkg/tags"
	"github.com/seniorGolang/i2s/pkg/utils"
)

var serviceMetricsMiddlewareName = utils.ToCamel(serviceMetricsStructName)

func renderServiceMiddlewareMetrics(info *meta.GenerationInfo) (err error) {

	srcFile := NewFileProxy(info.PkgName)

	srcFile.PackageComment("GENERATED BY i2s. DO NOT EDIT.")

	ctx := prepareContext(info)
	ctx = context.WithValue(ctx, "code", srcFile)

	srcFile.ImportName(info.SourcePackageImport, serviceAlias)
	srcFile.ImportName(packagePathKitLog, "logger")

	srcFile.Line().Add(loggingLog())

	srcFile.Line().Type().Id(middlewareTypeName).Func().Call(Qual(info.SourcePackageImport, info.Iface.Name)).Qual(info.SourcePackageImport, info.Iface.Name)

	srcFile.Line().Func().Id(serviceLoggingMiddlewareName).Params(Id("next").Qual(info.SourcePackageImport, info.Iface.Name)).Params(Qual(info.SourcePackageImport, info.Iface.Name)).
		Block(newLoggingBody(info))

	srcFile.Line()

	// Render type logger
	srcFile.Type().Id(serviceLoggingStructName).Struct(
		Id(_next_).Qual(info.SourcePackageImport, info.Iface.Name),
	)

	// Render functions
	for _, signature := range info.Iface.Methods {
		srcFile.Line()
		srcFile.Add(loggingFunc(ctx, signature, info)).Line()
	}

	return srcFile.Save(path.Join(info.OutputFilePath, "transport", strings.ToLower(info.ServiceName), "logging.go"))
}

func loggingLog() (code *Statement) {
	return Var().Id("log").Op("=").Qual(packagePathKitLog, "Log").Dot("WithField").Params(Lit("module"), Lit("server"))
}

func loggingFunc(ctx context.Context, signature *types.Function, info *meta.GenerationInfo) *Statement {
	return methodDefinition(ctx, serviceLoggingStructName, signature).BlockFunc(loggingFuncBody(signature, info))
}

func loggingFuncBody(signature *types.Function, info *meta.GenerationInfo) func(g *Group) {

	return func(g *Group) {

		g.Defer().Func().Params(Id("begin").Qual(packagePathTime, "Time")).BlockFunc(func(g *Group) {

			g.Id("fields").Op(":=").Qual(packagePathKitLog, "Fields").Values(DictFunc(func(d Dict) {

				d[Lit("x-user-id")] = Id(_ctx_).Op(".").Id("Value").Call(Lit("x-user-id"))
				d[Lit("x-trace-id")] = Id(_ctx_).Op(".").Id("Value").Call(Lit("x-trace-id"))
				d[Lit("service")] = Lit(info.ServiceName)
				d[Lit("method")] = Lit(utils.ToLowerCamel(signature.Name))

				skipFields := strings.Split(tags.ParseTags(signature.Docs).Value("log-skip"), ",")
				params := removeContextIfFirst(signature.Args)
				params = removeSkippedFields(params, skipFields)

				if len(params) == 1 {
					d[Lit("request")] = Id(params[0].Name)
				} else if len(params) > 1 {
					d[Lit("request")] = Id(requestStructName(signature)).Values(utils.DictByNormalVariables(params, params))
				}

				printResult := true
				for _, field := range skipFields {
					if strings.TrimSpace(field) == "response" {
						printResult = false
						break
					}
				}
				returns := removeErrorIfLast(signature.Results)

				if printResult {

					if len(returns) == 1 {
						d[Lit("response")] = Id(returns[0].Name)
					} else if len(returns) > 1 {
						d[Lit("response")] = Id(responseStructName(signature)).Values(utils.DictByNormalVariables(returns, returns))
					}
				}

				d[Lit("took")] = Qual(packagePathTime, "Since").Call(Id("begin"))
			}))

			g.Line()

			g.If(Id("err").Op("!=").Id("nil")).BlockFunc(func(g *Group) {

				g.Id("log").Dot("WithError").Call(Err()).Dot("WithFields").Call(Id("fields")).Dot("Info").Call(Lit(fmt.Sprintf("call %s", utils.ToLowerCamel(signature.Name))))
				g.Return()
			})

			g.Line()

			g.Id("log").Dot("WithFields").Call(Id("fields")).Dot("Info").Call(Lit(fmt.Sprintf("call %s", utils.ToLowerCamel(signature.Name))))

		}).Call(Qual(packagePathTime, "Now").Call())
		g.Return().Id(serviceLoggingStructName).Dot(_next_).Dot(signature.Name).Call(paramNames(signature.Args))
	}
}

func logRequest(fn *normalizedFunction) *Statement {
	paramAmount := calcParamAmount(fn.parent.Name, removeContextIfFirst(fn.parent.Args))
	if paramAmount <= 0 {
		return Lit("")
	}
	return Id("log" + requestStructName(fn.parent)).Add(fillMap(fn.parent, removeContextIfFirst(fn.parent.Args), removeContextIfFirst(fn.Args)))
}

func logResponse(fn *normalizedFunction) *Statement {
	paramAmount := calcParamAmount(fn.parent.Name, removeErrorIfLast(fn.parent.Results))
	if paramAmount <= 0 {
		return Lit("")
	}
	return Id("log" + responseStructName(fn.parent)).Add(fillMap(fn.parent, removeErrorIfLast(fn.parent.Results), removeContextIfFirst(fn.Results)))
}

func calcParamAmount(name string, params []types.Variable) int {

	paramAmount := len(params)
	return paramAmount
}

func loggingEntity(ctx context.Context, name string, fn *types.Function, params []types.Variable, info *meta.GenerationInfo) Code {
	if len(params) == 0 {
		return Empty()
	}

	return Id(name).StructFunc(func(g *Group) {

		for _, field := range params {

			g.Id(utils.ToCamel(field.Name)).Add(fieldType(ctx, field.Type, false))
			// g.Id("Len" + utils.ToCamel(field.Name)).Int().Tag(map[string]string{"json": "len(" + utils.ToCamel(field.Name) + ")"})
		}
	})
}

func newLoggingBody(info *meta.GenerationInfo) *Statement {

	return Return(Op("&").Id(serviceLoggingStructName).Values(
		Dict{
			Id(_next_): Id(_next_),
		},
	))
}

func fillMap(fn *types.Function, params, normal []types.Variable) *Statement {

	return Values(DictFunc(func(d Dict) {

		for i, field := range params {

			d[Id(utils.ToCamel(field.Name))] = Id(normal[i].Name)
			// d[Id("Len"+utils.ToCamel(field.Name))] = Len(Id(normal[i].Name))

		}
	}))
}
