package server

import (
	"context"
	"path"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/vetcher/go-astra/types"

	"github.com/seniorGolang/i2s/pkg/server/tools"
	"github.com/seniorGolang/i2s/pkg/tags"
	"github.com/seniorGolang/i2s/pkg/utils"
)

var pkgMetrics string

func renderTransportServer(info *GenerationInfo) (err error) {

	srcFile := NewFileProxy(info.PkgName)

	srcFile.PackageComment("GENERATED BY i2s. DO NOT EDIT.")

	pkgMetrics = path.Join(info.BasePackageImport, "transport", "metrics")

	srcFile.ImportName(pkgMetrics, "metrics")
	srcFile.ImportName(packageTypes, "types")
	srcFile.ImportName(info.SourcePackageImport, "service")
	srcFile.ImportName(packagePathGoKitEndpoint, "endpoint")

	ctx := prepareContext(info)
	ctx = context.WithValue(ctx, "code", srcFile)

	srcFile.Line().Add(serverEndPoints(info))

	srcFile.Add(allEndpoints(info)).Line()

	for _, signature := range info.Iface.Methods {
		srcFile.Add(createEndpoint(ctx, signature, info)).Line().Line()

	}

	return srcFile.Save(path.Join(info.OutputFilePath, "transport", strings.ToLower(info.ServiceName), "server.go"))
}

func serverEndPoints(info *GenerationInfo) (code *Statement) {
	ifaceTags := tags.ParseTags(info.Iface.Docs)

	var statement = Id("svc")
	if ok := ifaceTags.IsSet("log"); ok {
		statement = Id("LoggingMiddleware").Call(statement)
	}
	if ok := ifaceTags.IsSet("metrics"); ok {
		statement = Id("MetricsMiddleware").Call(statement)
	}
	statement = Id(endpointsFunc).Call(statement)

	if ok := ifaceTags.IsSet("trace"); ok {
		statement = Id("InstrumentingEndpoints").Call(statement, Id("tags").Op("..."))
	}

	return Func().Id("ServerEndpoints").Params(
		Id("svc").Qual(info.SourcePackageImport, utils.ToCamel(info.ServiceName)),
		Id("tags").Op("...").Qual(packageTypes, "KeyValue"),
	).Id(endpointsSetName).Block(Return(statement))
}

func allEndpoints(info *GenerationInfo) *Statement {

	s := &Statement{}
	s.Func().Id("Endpoints").Call(Id("svc").Qual(info.SourcePackageImport, info.Iface.Name)).Id(endpointsSetName).BlockFunc(func(g *Group) {
		g.Return(Id(endpointsSetName).Values(DictFunc(func(d Dict) {
			for _, signature := range info.Iface.Methods {
				d[Id(endpointsStructFieldName(signature.Name))] = Id(endpointsStructFieldName(signature.Name)).Params(Id("svc"))
			}
		})))
	})
	return s
}

func createEndpoint(ctx context.Context, signature *types.Function, info *GenerationInfo) *Statement {

	return Func().
		Id(endpointsStructFieldName(signature.Name)).
		Params(Id("svc").Qual(info.SourcePackageImport, info.Iface.Name)).
		Params(Qual(packagePathGoKitEndpoint, "Endpoint")).
		Block(createEndpointBody(ctx, signature))
}

func createEndpointBody(ctx context.Context, signature *types.Function) *Statement {

	return Return(Func().Params(
		Id("ctx").Qual("context", "Context"),
		Id("request").Interface(),
	).Params(
		Interface(),
		Error(),
	).BlockFunc(func(g *Group) {

		var ret []Code
		args := removeContextIfFirst(signature.Args)
		results := removeErrorIfLast(signature.Results)

		if len(args) != 0 {
			g.Id("req").Op(":=").Id("request").Assert(Id(requestStructName(signature)))
		}

		g.Add(paramNames(signature.Results).
			Op(":=").
			Id("svc").
			Dot(signature.Name).
			CallFunc(func(g *Group) {

				g.Add(Id("ctx"))

				for _, field := range args {

					v := Dot(utils.ToCamel(structRequestFieldName(field)))

					if types.IsEllipsis(field.Type) {
						v.Op("...")
					}
					g.Add(Id("req").Add(v))
				}
			}))

		if len(results) == 0 {
			g.Return(
				Id("nil"),
				Id(nameOfLastResultError(signature)),
			)
		} else {
			ret = append(ret,
				Id(responseStructName(signature)).Values(tools.DictByNormalVariables(
					removeErrorIfLast(signature.Results),
					removeErrorIfLast(signature.Results),
				)),
				Id(nameOfLastResultError(signature)),
			)
			g.Return(ret...)
		}
	}))
}
